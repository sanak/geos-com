<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>GEOS COM Wrapper Tester</title>
    <link rel="stylesheet" href="./theme/default/style.css" type="text/css" />
    <link rel="stylesheet" href="style.css" type="text/css" />
    <style type="text/css">
        td {
            padding: 2px;
            vertical-align: center;
        }
        #selTestXml {
            width: 300px;
        }
        #selTestCase {
            width: 500px;
        }
        #controlpanel {
            top: 0;
            padding: 0;
            width: 226px;
            height: 426px;
        }
        #selOperation {
            width: 100%;
        }
        #map {
            width: 426px;
            height: 426px;
            border: 1px solid #ccc;
        }
        #txtInput {
            font-size: 0.85em;
            width: 100%;
            height: 100%;
        }
        #txtOutput {
            font-size: 0.85em;
            width: 100%;
            height: 100%;
        }
        #iopanel {
            height: 150px;
        }
        #lblA {
            color: blue;
        }
        #lblB {
            color: red;
        }
        #lblResult {
            color: #acd62b;
        }
        #lblExpected {
            color: #2bd656;
        }
        p {
            margin: 0;
            padding: 0.75em 0 0.75em 0;
        }
        td.testlabel {
            width: 90px;
        }
        table.tests {
            width: 100%;
        }
        table.controls {
            width: 100%;
            height: 100%;
        }
        td.controlpanel {
            vertical-align: center;
        }
        td.arglabel {
            width: 120px;
        }
        td.argtext {
            text-align: right;
        }
        input.txtArg {
            width: 100px;
            text-align: right;
        }
        td.iolabel {
            width: 90px;
            height: 75px;
            list-style: none;
            vertical-align: top;
        }
        td.iobutton {
            vertical-align: top;
            text-align: center;
        }
        td.iotext {
            width: 500px;
        }
        option.unary {
            background-image: url("./img/unary-geom-function.png");
            background-repeat: no-repeat;
            color: blue;
        }
        option.binary {
            background-image:url("./img/binary-geom-function.png");
            background-repeat:no-repeat;
            color: red;
        }
    </style>
    <script src="./OpenLayers.js"></script>
    <script src="./EditingToolbarExt.js"></script>
    <script type="text/javascript">
        var map, wktfmt, layerInput, layerOutput;
        var featureA, featureB, featureResult, featureExpected;
        var result, expected;
        var geos, xmlhttp, xmldom;
        
        function init(){
            var options = {
                units: 'm',
                maxExtent: new OpenLayers.Bounds(-100000000000000000000, -100000000000000000000, 100000000000000000000, 100000000000000000000), // limit of number "e" format
                controls: [
                    new OpenLayers.Control.PanZoomBar(),
                    new OpenLayers.Control.MousePosition()
                ],
                numZoomLevels: 16
            };
            map = new OpenLayers.Map('map', options);
            wktfmt = new OpenLayers.Format.WKT({'externalProjection': new OpenLayers.Projection("EPSG:4326")});
            var graphic = new OpenLayers.Layer.Image( "OpenLayers Image",
                "./img/blank.gif",
                new OpenLayers.Bounds(-100000, -100000, 100000, 100000), // TODO: initial scale ?
                new OpenLayers.Size(426, 426)
                );
            
            layerInput = new OpenLayers.Layer.Vector("Vector Layer");
            layerOutput = new OpenLayers.Layer.Vector("Vector Layer");
            
            map.addLayers([graphic, layerInput, layerOutput]);
            map.addControl(new OpenLayers.Control.EditingToolbarExt(layerInput));
            
            map.zoomToExtent(new OpenLayers.Bounds(-10, -10, 416, 416));
            
            // init controls and variables
            result = "";
            expected = "";
            document.getElementById("radA").click();
            updateOperation("intersection");
            
            // load embedded objects
            var url = location.toString();
            if (url.indexOf("http://") == 0) {
                try {
                    xmlhttp = new XMLHttpRequest();
                } catch (ex) {
                    try {
                        xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
                    } catch (ex) {
                    }
                }
            } else if (url.indexOf("file://") == 0) {
                try {
                    xmldom = new ActiveXObject("Microsoft.XMLDOM");
                } catch (ex) {
                }
            }
            if (isEmpty(xmlhttp) && isEmpty(xmldom)) {
                document.getElementById("selTestXml").disabled = true;
                document.getElementById("btnLoad").disabled = true;
                document.getElementById("selTestCase").disabled = true;
            }
            
            try {
                geos = new ActiveXObject("geos.geos");
            } catch (ex) {
                geos = null;
            }
        }
        
        function toWkt(feature) {
            var str = "";
            if (isEmpty(feature)) {
                return str;
            }
            
            if (feature.constructor != Array) {
                str = wktfmt.write(feature);
                // not a good idea in general, just for this demo
                str = str.replace(/,/g, ', ');
            } else {
                str = "GEOMETRYCOLLECTION(";
                for (var i = 0; i < feature.length; i++) {
                    str += wktfmt.write(feature[i]);
                    if (i != feature.length - 1) {
                       str += ", ";
                    }
                }
                str += ")";
            }
            return str;
        }
        
        function fromWkt(wkt) {
            if (isEmpty(wkt)) {
                return null;
            }
            //// remove "GEOMETRYCOLLECTION("+")" for OpenLayers
            //var regexp = /GEOMETRYCOLLECTION\s*\(([\w,\s\(\)]+)\)/g
            //wkt = wkt.replace(regexp, "$1");
            var feature = wktfmt.read(wkt);
            return feature;
        }
        
        function addFeatures(layer, feature) {
            if (isEmpty(feature)) {
                return;
            }
            
            var bounds = map.getExtent();
            if (feature.constructor != Array) {
                bounds.extend(feature.geometry.getBounds());
                layer.addFeatures([feature]);
            } else {
                for (var i = 0; i < feature.length; i++) {
                    bounds.extend(feature[i].geometry.getBounds());
                }
                layer.addFeatures(feature);
            }
            map.zoomToExtent(bounds);
        }
        
        function destroyFeatures(layer, feature) {
            if (isEmpty(feature)) {
                return;
            }
            
            if (feature.constructor != Array) {
                layer.destroyFeatures([feature]);
            } else {
                layer.destroyFeatures(feature);
            }
            feature = null;
        }
        
        function loadInput(wkt, strtype) {
            if (isEmpty(wkt)) {
                wkt = document.getElementById("txtInput").value;
            }
            var feature = fromWkt(wkt);
            
            if (isEmpty(strtype)) {
                strtype = getInputType();
            }
            if (feature) {
                setFeatureType(feature, strtype);
                setFeatureStyle(feature, strtype);
                addFeatures(layerInput, feature);
                if (strtype == "a") {
                    destroyFeatures(layerInput, featureA);
                    featureA = feature;
                } else if (strtype == "b") {
                    destroyFeatures(layerInput, featureB);
                    featureB = feature;
                }
            }
        }
        
        function loadOutput() {
            if (!isEmpty(result)) {
                var feature = fromWkt(result);
                if (feature) {
                    setFeatureStyle(feature, "result");
                    addFeatures(layerOutput, feature);
                    destroyFeatures(layerOutput, featureResult);
                    featureResult = feature;
                }
            }
            if (!isEmpty(expected)) {
                var feature = fromWkt(expected);
                if (feature) {
                    setFeatureStyle(feature, "expected");
                    addFeatures(layerOutput, feature);
                    destroyFeatures(layerOutput, featureExpected);
                    featureExpected = feature;
                }
            }
        }
        
        function isEmpty(value) {
            switch (typeof(value)) {
            case "undefined":
                return true;
                break;
            case "object":
                if (value == null) {
                    return true;
                }
                break;
            case "string":
                if (value == "") {
                    return true;
                }
                break;
            }
            return false;
        }
        
        function getInputType() {
            if (document.getElementById("radA").checked) {
                return "a";
            } else if (document.getElementById("radB").checked) {
                return "b";
            }
            return "a";
        }
        
        function setInputType(strtype) {
            if (strtype == "a") {
                document.getElementById("radA").checked = true;
            } else if (strtype == "b") {
                document.getElementById("radB").checked = true;
            }
        }
        
        function getOutputType() {
            if (document.getElementById("radResult").checked) {
                return "result";
            } else if (document.getElementById("radExpected").checked) {
                return "expected";
            }
            return "result";
        }
        
        function setOutputType(strtype) {
            if (strtype == "result") {
                document.getElementById("radResult").checked = true;
            } else if (strtype == "expected") {
                document.getElementById("radExpected").checked = true;
            }
        }
        
        function setDefaultStyle(strtype) {
            if (strtype == "a") {
                OpenLayers.Feature.Vector.style['default'].strokeColor = "#2929fd";
                OpenLayers.Feature.Vector.style['default'].fillColor = "#dfdfff";
            } else if (strtype == "b") {
                OpenLayers.Feature.Vector.style['default'].strokeColor = "#a52929";
                OpenLayers.Feature.Vector.style['default'].fillColor = "#ffdfdf";
            }
        }
        
        function setFeatureStyle(feature, strtype) {
            if (isEmpty(feature)) {
                return;
            }
            
            var style = {
                fillColor: "#ee9900",
                fillOpacity: 0.4, 
                hoverFillColor: "white",
                hoverFillOpacity: 0.8,
                strokeColor: "#ee9900",
                strokeOpacity: 1,
                strokeWidth: 1,
                strokeLinecap: "round",
                strokeDashstyle: "solid",
                hoverStrokeColor: "red",
                hoverStrokeOpacity: 1,
                hoverStrokeWidth: 0.2,
                pointRadius: 6,
                hoverPointRadius: 1,
                hoverPointUnit: "%",
                pointerEvents: "visiblePainted",
                cursor: "inherit"
            };
            if (strtype == "a") {
                style.strokeColor = "#2929fd";
                style.fillColor = "#dfdfff";
            } else if (strtype == "b") {
                style.strokeColor = "#a52929";
                style.fillColor = "#ffdfdf";
            } else if (strtype == "result") {
                style.strokeColor = "#acd62b";
                style.fillColor = "#ffffc2";
            } else if (strtype == "expected") {
                style.strokeColor = "#2bd656";
                style.fillColor = "#c2ffc2";
            }
            
            if (feature.constructor != Array) {
                feature.style = style;
            } else {
                for (var i = 0; i < feature.length; i++) {
                    feature[i].style = style;
                }
            }
        }
        
        function setFeatureType(feature, strtype) {
            if (isEmpty(feature)) {
                return;
            }
            
            if (feature.constructor != Array) {
                feature.attributes["type"] = strtype;
            } else {
                for (var i = 0; i < feature.length; i++) {
                    feature[i].attributes["type"] = strtype;
                }
            }
        }
        
        function displayInputGeometries(visibility) {
            layerInput.setVisibility(visibility);
        }
        
        function updateInput() {
            var strtype = getInputType();
            var wkt = "";
            if (strtype == "a") {
                wkt = toWkt(featureA);
            } else if (strtype == "b") {
                wkt = toWkt(featureB);
            }
            document.getElementById("txtInput").value = wkt;
            setDefaultStyle(strtype);
        }
        
        function updateOutput() {
            var strtype = getOutputType();
            var txtOutput = document.getElementById("txtOutput");
            if (strtype == "result") {
                txtOutput.value = result;
            } else if (strtype == "expected") {
                txtOutput.value = expected;
            }
            if (!isEmpty(result) && !isEmpty(expected)) {
                if (result != expected) {
                    txtOutput.style.backgroundColor = "#ffcccc";
                } else {
                    txtOutput.style.backgroundColor = "#ccffcc";
                }
            } else {
                txtOutput.style.backgroundColor = "#ffffff";
            }
        }
        
        function clearInput(all) {
            if (getInputType() == "a" || all) {
                destroyFeatures(layerInput, featureA);
            }
            if (getInputType() == "b" || all) {
                destroyFeatures(layerInput, featureB);
            }
            document.getElementById("txtInput").value = "";
        }
        
        function clearOutput() {
            result = "";
            expected = "";
            destroyFeatures(layerOutput, featureResult);
            destroyFeatures(layerOutput, featureExpected);
            var txtOutput = document.getElementById("txtOutput");
            txtOutput.value = "";
            txtOutput.style.backgroundColor = "#ffffff";
        }
        
        function setArgument(idx, label, value, disabled) {
            var lblArg = document.getElementById("lblArg" + idx);
            var txtArg = document.getElementById("txtArg" + idx);
            lblArg.textContent = label; // FireFox
            lblArg.innerText = label; // IE
            txtArg.value = value;
            txtArg.disabled = disabled;
        }
        
        function updateOperation(opname, arg1, arg2, arg3) {
            var selOperation = document.getElementById("selOperation");
            if (selOperation.value != opname.toLowerCase()) {
                var optsOperation = selOperation.options;
                for (var i = 0; i < optsOperation.length; i++) {
                    if (optsOperation[i].value == opname.toLowerCase()) {
                        optsOperation[i].selected = true;
                        break;
                    }
                }
            }
            setArgument(1, "Geometry", "A", true);
            switch (opname.toLowerCase()) {
            // simple unary
            case "convexhull":
            case "getboundary":
            case "pointonsurface":
            case "getcentroid":
            case "envelope":
            case "linemerge":
            case "isempty":
            case "isvalid":
            case "issimple":
            case "isring":
            case "hasz":
            case "area":
            case "length":
                setArgument(2, "", "", true);
                setArgument(3, "", "", true);
                break;
            // simple binary
            case "intersection":
            case "difference":
            case "symdifference":
            case "union":
            case "relate":
            case "disjoint":
            case "touches":
            case "intersects":
            case "crosses":
            case "within":
            case "contains":
            case "overlaps":
            case "equals":
            case "distance":
                setArgument(2, "Geometry", "B", true);
                setArgument(3, "", "", true);
                break;
            case "buffer":
                setArgument(2, "Distance", "10", false);
                setArgument(3, "Quadrant Segs", "8", false);
                break;
            case "simplify":
            case "topologypreservesimplify":
                setArgument(2, "Tolerance", "10", false);
                setArgument(3, "", "", true);
                break;
            case "equalsexact":
                setArgument(2, "Geometry", "B", true);
                setArgument(3, "Tolerance", "0.00001", false); // TODO: reasonable initial value
                break;
            case "relatepattern":
                setArgument(2, "Geometry", "B", true);
                setArgument(3, "Pattern", "FFFFFFFFF", false); // TODO: reasonable initial value
                break;
            default:
                alert('"' + opname + '" operation not supported.');
                return false;
                break;
            }
            if (!isEmpty(arg1)) {
                document.getElementById("txtArg1").value = arg1;
            }
            if (!isEmpty(arg2)) {
                document.getElementById("txtArg2").value = arg2;
            }
            if (!isEmpty(arg3)) {
                document.getElementById("txtArg3").value = arg3;
            }
            return true;
        }
        
        function compute(exp) {
            if (isEmpty(exp) && isEmpty(geos)) {
                alert("Compute function needs IE6/7 and geos_com.dll registered environment!");
                return;
            }
            
            clearOutput();
            
            if (!isEmpty(exp)) {
                expected = exp;
                document.getElementById("radExpected").disabled = false;
                if (isEmpty(geos)) {
                    setOutputType("expected");
                }
            } else {
                document.getElementById("radExpected").disabled = true;
            }
            
            var opts = document.getElementById("selOperation").options;
            var opname = opts[opts.selectedIndex].value;
            var fncname = opts[opts.selectedIndex].text;
            fncname = fncname.replace(/\W+/g, "");
            
            if (isEmpty(featureA)) {
                alert("all operation needs Geometry A.");
                return;
            }
            var reader, writer;
            var geomA, geomB, geomResult;
            
            if (!isEmpty(geos)) {
                reader = geos.WktReader.new_WktReader();
                writer = geos.WktWriter.new_WktWriter();
                geomA = reader.read(toWkt(featureA));
            }
            
            switch (opname.toLowerCase()) {
            // simple unary (return geometry)
            case "convexhull":
            case "getboundary":
            case "pointonsurface":
            case "getcentroid":
            case "envelope":
            case "linemerge":
                if (!isEmpty(geos)) {
                    geomResult = geomA[fncname]();
                    result = writer.write(geomResult);
                    if (!isEmpty(expected)) {
                        expected = writer.write(reader.read(expected));
                    }
                }
                updateOutput();
                loadOutput();
                break;
            // simple unary (return scalar)
            case "isempty":
            case "isvalid":
            case "issimple":
            case "isring":
            case "hasz":
            case "area":
            case "length":
                if (!isEmpty(geos)) {
                    result = geomA[fncname]();
                    result = result.toString();
                }
                updateOutput();
                break;
            // simple binary (return geometry)
            case "intersection":
            case "difference":
            case "symdifference":
            case "union":
                if (!isEmpty(geos)) {
                    if (isEmpty(featureB)) {
                        alert('"' + fncname + '" operation needs Geometry B.');
                        return;
                    }
                    geomB = reader.read(toWkt(featureB));
                    geomResult = geomA[fncname](geomB);
                    result = writer.write(geomResult);
                    if (!isEmpty(expected)) {
                        expected = writer.write(reader.read(expected));
                    }
                }
                updateOutput();
                loadOutput();
                break;
            case "relate":
            case "disjoint":
            case "touches":
            case "intersects":
            case "crosses":
            case "within":
            case "contains":
            case "overlaps":
            case "equals":
            case "distance":
                if (!isEmpty(geos)) {
                    if (isEmpty(featureB)) {
                        alert('"' + fncname + '" operation needs Geometry B.');
                        return;
                    }
                    geomB = reader.read(toWkt(featureB));
                    result = geomA[fncname](geomB);
                    result = result.toString();
                }
                updateOutput();
                break;
            case "buffer":
                if (!isEmpty(geos)) {
                    var distance = document.getElementById("txtArg2").value;
                    if (isNaN(distance)) {
                        alert("Distance value must be number.");
                        return;
                    }
                    distance = parseFloat(distance);
                    var quadsegs = document.getElementById("txtArg3").value;
                    if (isNaN(quadsegs)) {
                        alert("Quadrant Segs value must be number.");
                        return;
                    }
                    quadsegs = parseInt(quadsegs);
                    geomResult = geomA[fncname](distance, quadsegs);
                    result = writer.write(geomResult);
                    if (!isEmpty(expected)) {
                        expected = writer.write(reader.read(expected));
                    }
                }
                updateOutput();
                loadOutput();
                break;
            case "simplify":
            case "topologypreservesimplify":
                if (!isEmpty(geos)) {
                    var tolerance = document.getElementById("txtArg2").value;
                    if (isNaN(tolerance)) {
                        alert("Tolerance value must be number.");
                        return;
                    }
                    tolerance = parseFloat(tolerance);
                    geomResult = geomA[fncname](tolerance);
                    result = writer.write(geomResult);
                    if (!isEmpty(expected)) {
                        expected = writer.write(reader.read(expected));
                    }
                }
                updateOutput();
                loadOutput();
                break;
            case "equalsexact":
                if (!isEmpty(geos)) {
                    var tolerance = document.getElementById("txtArg3").value;
                    if (isNaN(tolerance)) {
                        alert("Tolerance value must be number.");
                        return;
                    }
                    tolerance = parseFloat(tolerance);
                    if (isEmpty(featureB)) {
                        alert('"' + fncname + '" operation needs Geometry B.');
                        return;
                    }
                    geomB = reader.read(toWkt(featureB));
                    result = geomA[fncname](geomB, tolerance);
                    result = result.toString();
                }
                updateOutput();
                break;
            case "relatepattern":
                if (!isEmpty(geos)) {
                    var pattern = document.getElementById("txtArg3").value;
                    if (isEmpty(featureB)) {
                        alert('"' + fncname + '" operation needs Geometry B.');
                        return;
                    }
                    geomB = reader.read(toWkt(featureB));
                    result = geomA[fncname](geomB, pattern);
                    result= result.toString();
                }
                updateOutput();
                break;
            }
        }
        
        function loadTestXml() {
            var optsTestXml = document.getElementById("selTestXml").options;
            var optsTestCase = document.getElementById("selTestCase").options;
            
            optsTestCase.length = 1;
            
            if (optsTestXml.selectedIndex == 0) {
                xmldom = null;
                return;
            }
            var filename = optsTestXml[optsTestXml.selectedIndex].text;
            
            if (!isEmpty(xmlhttp)) {
                xmlhttp.open("get", filename, false);
                xmlhttp.send(null);
                xmldom = xmlhttp.responseXML;
            } else if (!isEmpty(xmldom)) {
                xmldom.load(filename);
            }
            
            if (!isEmpty(xmldom)) {
                var nodeCases = xmldom.getElementsByTagName("case");
                optsTestCase.length = nodeCases.length + 1;
                for (var i = 0; i < nodeCases.length; i++) {
                    optsTestCase[i + 1].text = nodeCases[i].getElementsByTagName("desc")[0].firstChild.data;
                }
            }
        }
        
        function loadTestCase() {
            clearInput(true);
            clearOutput();
            
            if (isEmpty(xmldom)) {
                return;
            }
            var caseIdx = document.getElementById("selTestCase").options.selectedIndex;
            if (caseIdx == 0) {
                return;
            }
            
            var nodeCase = xmldom.getElementsByTagName("case")[caseIdx - 1];
            var a = nodeCase.getElementsByTagName("a")[0].firstChild.data;
            a = a.replace(/^\s+|\n|\s+$/g, "");
            var b = null;
            var nodeBs = nodeCase.getElementsByTagName("b");
            if (nodeBs.length > 0) {
                b = nodeBs[0].firstChild.data;
                b = b.replace(/^\s+|\n|\s+$/g, "");
            }
            var nodeTest = nodeCase.getElementsByTagName("test")[0];
            var nodeOp = nodeTest.getElementsByTagName("op")[0];
            var opname = nodeOp.getAttribute("name");
            var arg1 = nodeOp.getAttribute("arg1");
            var arg2 = nodeOp.getAttribute("arg2");
            var arg3 = nodeOp.getAttribute("arg3");
            var exp = nodeOp.firstChild.data;
            exp = exp.replace(/^\s+|\n|\s+$/g, "");
            switch (opname) {
            case "relate":
                opname = "relatepattern";
                break;
            }
            //alert("a:\t" + a + "\nb:\t" + b + "\nopname:\t" + opname + "\narg1:\t" + arg1 + "\narg2:\t" + arg2 + "\narg3:\t" + arg3);
            loadInput(a, "a");
            updateInput();
            if (!isEmpty(b)) {
                loadInput(b, "b");
                updateInput();
            }
            if (updateOperation(opname, arg1, arg2, arg3)) {
                compute(exp);
            }
        }
        
        // preload images
        (function() {
            var roots = ["draw_point", "draw_line", "draw_polygon", "pan", "move_feature"];
            var onImages = [];
            var offImages = [];
            for (var i = 0; i < roots.length; ++i) {
                onImages[i] = new Image();
                onImages[i].src = "./theme/default/img/" + roots[i] + "_on.png";
                offImages[i] = new Image();
                offImages[i].src = "./theme/default/img/" + roots[i] + "_on.png";
            }
        })();

    </script>
  </head>
  <body onload="init()">
    <h1 id="title">GEOS COM Wrapper Tester</h1>

    <div id="tags">
    </div>

    <p id="shortdesc">
      Demonstrate GEOS COM Wrapper
    </p>

    <table id="panels">
      <tbody>
        <tr>
          <td id="testpanel" colspan="2">
            <table class="tests">
              <tbody>
                <tr>
                  <td class="testlabel">
                    <label for="selTestXml">TestXml</label>
                  </td>
                  <td>
                    <select name="selTestXml" id="selTestXml">
                      <option selected="selected">&nbsp;---&nbsp;Select Below&nbsp;---&nbsp;</option>
                      <option>../testxml/general/TestBoundary.xml</option>
                      <option>../testxml/general/TestCentroid.xml</option>
                      <option>../testxml/general/TestConvexHull-big.xml</option>
                      <option>../testxml/general/TestConvexHull.xml</option>
                      <option>../testxml/general/TestFunctionAA.xml</option>
                      <option>../testxml/general/TestFunctionAAPrec.xml</option>
                      <option>../testxml/general/TestFunctionLA.xml</option>
                      <option>../testxml/general/TestFunctionLAPrec.xml</option>
                      <option>../testxml/general/TestFunctionLL.xml</option>
                      <option>../testxml/general/TestFunctionLLPrec.xml</option>
                      <option>../testxml/general/TestFunctionPA.xml</option>
                      <option>../testxml/general/TestFunctionPL.xml</option>
                      <option>../testxml/general/TestFunctionPLPrec.xml</option>
                      <option>../testxml/general/TestFunctionPP.xml</option>
                      <option>../testxml/general/TestInteriorPoint.xml</option> <!-- getInteriorPoint function not supported in GEOS CAPI -->
                      <!-- <option>../testxml/general/TestRectanglePredicate.xml</option> --> <!-- multiple tests per one case not supported -->
                      <option>../testxml/general/TestRelateAA.xml</option>
                      <option>../testxml/general/TestRelateAC.xml</option>
                      <option>../testxml/general/TestRelateLA.xml</option>
                      <option>../testxml/general/TestRelateLC.xml</option>
                      <option>../testxml/general/TestRelateLL.xml</option>
                      <option>../testxml/general/TestRelatePA.xml</option>
                      <option>../testxml/general/TestRelatePL.xml</option>
                      <option>../testxml/general/TestRelatePP.xml</option>
                      <option>../testxml/general/TestSimple.xml</option>
                      <option>../testxml/general/TestValid.xml</option>
                      <option>../testxml/general/TestValid2-big.xml</option>
                      <option>../testxml/general/TestValid2.xml</option>
                      <option>../testxml/general/TestWithinDistance.xml</option> <!-- isWithinDistance function not supported in GEOS CAPI -->
                      <option>../testxml/robust/TestRobustOverlayFixed.xml</option>
                      <option>../testxml/robust/TestRobustOverlayFloat.xml</option>
                      <option>../testxml/robust/TestRobustRelate.xml</option>
                      <option>../testxml/validate/TestRelateAA-big.xml</option>
                      <option>../testxml/validate/TestRelateAA.xml</option>
                      <option>../testxml/validate/TestRelateAC.xml</option>
                      <option>../testxml/validate/TestRelateLA.xml</option>
                      <option>../testxml/validate/TestRelateLC.xml</option>
                      <option>../testxml/validate/TestRelateLL.xml</option>
                      <option>../testxml/validate/TestRelatePA.xml</option>
                      <option>../testxml/validate/TestRelatePL.xml</option>
                      <option>../testxml/validate/TestRelatePP.xml</option>
                    </select>
                    <input type="button" id="btnLoad" value="Load" onclick="loadTestXml();"/><br/>
                  </td>
                </tr>
                <tr>
                  <td class="testlabel">
                    <label for="selTestCase">TestCase</label>
                  </td>
                  <td>
                    <select name="selTestCase" id="selTestCase" onchange="loadTestCase();">
                      <option selected="selected">&nbsp;---&nbsp;Select Below&nbsp;---&nbsp;</option>
                    </select>
                  </td>
                </tr>
              </tbody>
            </table>
          </td>
        </tr>
        <tr>
          <td id="controlpanel">
            <table class="controls">
              <tbody>
                <tr>
                  <td colspan="2">
                    <label for="selOperation">Operation(<img src="./img/unary-geom-function.png"/><font color="blue">:unary</font>/<img src="./img/binary-geom-function.png"><font color="red">:binary</font>)</label>
                    <select size="17" name="selOperation" id="selOperation" onchange="updateOperation(this.value)">
                      <option value="intersection" class="binary" selected="selected">&nbsp;&nbsp;&nbsp;intersection</option>
                      <option value="buffer" class="unary">&nbsp;&nbsp;&nbsp;buffer</option>
                      <option value="convexhull" class="unary">&nbsp;&nbsp;&nbsp;convexHull</option>
                      <option value="difference" class="binary">&nbsp;&nbsp;&nbsp;difference</option>
                      <option value="symdifference" class="binary">&nbsp;&nbsp;&nbsp;symDifference</option>
                      <option value="getboundary" class="unary">&nbsp;&nbsp;&nbsp;boundary</option>
                      <option value="union" class="binary">&nbsp;&nbsp;&nbsp;Union</option>
                      <option value="pointonsurface" class="unary">&nbsp;&nbsp;&nbsp;pointOnSurface</option>
                      <option value="getcentroid" class="unary">&nbsp;&nbsp;&nbsp;getCentroid</option>
                      <option value="envelope" class="unary">&nbsp;&nbsp;&nbsp;getEnvelope</option>
                      <option value="relate" class="binary">&nbsp;&nbsp;&nbsp;relate</option>
                      <!-- <option value="polygonize" class="unary">&nbsp;&nbsp;&nbsp;polygonize</option> --> <!-- SWIG interface not supported -->
                      <option value="linemerge" class="unary">&nbsp;&nbsp;&nbsp;lineMerge</option>
                      <option value="simplify" class="unary">&nbsp;&nbsp;&nbsp;simplify</option>
                      <option value="topologypreservesimplify" class="unary">&nbsp;&nbsp;&nbsp;topologyPreserveSimplify</option>
                      <option value="relatepattern" class="binary">&nbsp;&nbsp;&nbsp;relatePattern</option>
                      <option value="disjoint" class="binary">&nbsp;&nbsp;&nbsp;disjoint</option>
                      <option value="touches" class="binary">&nbsp;&nbsp;&nbsp;touches</option>
                      <option value="intersects" class="binary">&nbsp;&nbsp;&nbsp;intersects</option>
                      <option value="crosses" class="binary">&nbsp;&nbsp;&nbsp;crosses</option>
                      <option value="within" class="binary">&nbsp;&nbsp;&nbsp;within</option>
                      <option value="contains" class="binary">&nbsp;&nbsp;&nbsp;contains</option>
                      <option value="overlaps" class="binary">&nbsp;&nbsp;&nbsp;overlaps</option>
                      <option value="equals" class="binary">&nbsp;&nbsp;&nbsp;equals</option>
                      <option value="equalsexact" class="binary">&nbsp;&nbsp;&nbsp;equalsExact</option>
                      <option value="isempty" class="unary">&nbsp;&nbsp;&nbsp;isEmpty</option>
                      <option value="isvalid" class="unary">&nbsp;&nbsp;&nbsp;isValid</option>
                      <option value="issimple" class="unary">&nbsp;&nbsp;&nbsp;isSimple</option>
                      <option value="isring" class="unary">&nbsp;&nbsp;&nbsp;isRing</option>
                      <option value="hasz" class="unary">&nbsp;&nbsp;&nbsp;hasZ</option>
                      <option value="area" class="unary">&nbsp;&nbsp;&nbsp;area</option>
                      <option value="length" class="unary">&nbsp;&nbsp;&nbsp;length</option>
                      <option value="distance" class="binary">&nbsp;&nbsp;&nbsp;distance</option>
                    </select>
                  </td>
                </tr>
                <tr>
                  <td colspan="2" style="text-align:center;">
                    <input type="button" id="btnCompute" value="Compute" onclick="compute();"/>
                  </td>
                <tr>
                  <td class="arglabel">
                    <label for="txtArg1" id="lblArg1">Argument1</label>
                  </td>
                  <td class="argtext">
                    <input type="text" id="txtArg1" class="txtArg"/>
                  </td>
                </tr>
                <tr>
                  <td class="arglabel">
                    <label for="txtArg2" id="lblArg2">Argument2</label>
                  </td>
                  <td class="argtext">
                    <input type="text" id="txtArg2" class="txtArg"/>
                  </td>
                </tr>
                <tr>
                  <td class="arglabel">
                    <label for="txtArg3" id="lblArg3">Argument3</label>
                  </td>
                  <td class="argtext">
                    <input type="text" id="txtArg3" class="txtArg"/>
                  </td>
                </tr>
                <tr>
                  <td id="option" colspan="2">
                    <input type="checkbox" id="chkDisplay" name="chkDisplay" checked="checked" onclick="displayInputGeometries(this.checked);"/>
                    <label for="chkDisplay">Display Input Geometries</label>
                  </td>
                </tr>
              </tbody>
            </table>
          </td>
          <td id="mappanel">
            <div id="map"></div>
          </td>
        </tr>
        <tr>
          <td id="iopanel" colspan="2">
            <table class="controls">
              <tbody>
                <tr class="io">
                  <td class="iolabel">
                    <input type="radio" name="inputtype" id="radA" value="a" checked="checked" onclick="updateInput();"/>
                    <label for="radA" id="lblA">A</label><br/>
                    <input type="radio" name="inputtype" id="radB" value="b" onclick="updateInput();"/>
                    <label for="radB" id="lblB">B</label><br/>
                  </td>
                  <td class="iotext">
                    <textarea id="txtInput"></textarea>
                  </td>
                  <td class="iobutton">
                      <input type="button" id="btnClearInput" value="Clear" onclick="clearInput();"/><br/>
                      <input type="button" id="btnLoadInput" value="Load" onclick="loadInput();"/>
                  </td>
                </tr>
                <tr class="io">
                  <td class="iolabel">
                    <input type="radio" name="outputtype" id="radResult" value="result" checked="checked" onclick="updateOutput();"/>
                    <label for="radResult" id="lblResult">Result</label><br/>
                    <input type="radio" name="outputtype" id="radExpected" value="expected" onclick="updateOutput();"/>
                    <label for="radExpected" id="lblExpected">Expected</label><br/>
                  </td>
                  <td class="iotext">
                    <textarea id="txtOutput"></textarea>
                  </td>
                  <td class="iobutton">
                      <input type="button" id="btnClearOutput" value="Clear" onclick="clearOutput();"/><br/>
                  </td>
                </tr>
              </tbody>
            </table>
          </td>
        </tr>
      </tbody>
    </table>
  </body>
</html>
