Index: capi/geos_c.cpp
===================================================================
--- capi/geos_c.cpp	(revision 2101)
+++ capi/geos_c.cpp	(working copy)
@@ -73,6 +73,7 @@
 #endif
 
 // import the most frequently used definitions globally
+using geos::geom::BinaryOp;
 using geos::geom::Geometry;
 using geos::geom::LineString;
 using geos::geom::Polygon;
@@ -325,8 +326,8 @@
 				return NULL;
 
 		s= im->toString();
-		result = (char*) std::malloc( s.length() + 1);
-		std::strcpy(result, s.c_str() );
+		result = (char*) malloc( s.length() + 1);
+		strcpy(result, s.c_str() );
 		delete im;
 
 		return result;
@@ -530,8 +531,8 @@
 		std::string s = g1->toString();
 
 		char *result;
-		result = (char*) std::malloc( s.length() + 1);
-		std::strcpy(result, s.c_str() );
+		result = (char*) malloc( s.length() + 1);
+		strcpy(result, s.c_str() );
 		return result;
 	}
 	catch (const std::exception &e)
@@ -562,7 +563,7 @@
 		size_t len = wkbstring.length();
 
 		unsigned char *result;
-		result = (unsigned char*) std::malloc(len);
+		result = (unsigned char*) malloc(len);
 		memcpy(result, wkbstring.c_str(), len);
 		*size = len;
 		return result;
@@ -624,7 +625,7 @@
 		size_t len = hexstring.length();
 
 		char *result;
-		result = (char*) std::malloc(len);
+		result = (char*) malloc(len);
 		memcpy(result, hexstring.c_str(), len);
 		*size = len;
 		return (unsigned char*) result;
@@ -746,8 +747,8 @@
 		std::string s = g1->getGeometryType();
 
 		char *result;
-		result = (char*) std::malloc( s.length() + 1);
-		std::strcpy(result, s.c_str() );
+		result = (char*) malloc( s.length() + 1);
+		strcpy(result, s.c_str() );
 		return result;
 	}
 	catch (const std::exception &e)
@@ -1982,8 +1983,8 @@
 		std::string s = writer->write(geom);
 
 		char *result;
-		result = (char*) std::malloc( s.length() + 1);
-		std::strcpy(result, s.c_str() );
+		result = (char*) malloc( s.length() + 1);
+		strcpy(result, s.c_str() );
 		return result;
 	}
 	catch (const std::exception &e)
@@ -2145,7 +2146,7 @@
 		size_t len = wkbstring.length();
 
 		unsigned char *result;
-		result = (unsigned char*) std::malloc(len);
+		result = (unsigned char*) malloc(len);
 		memcpy(result, wkbstring.c_str(), len);
 		*size = len;
 		return result;
@@ -2175,7 +2176,7 @@
 		size_t len = wkbstring.length();
 
 		unsigned char *result;
-		result = (unsigned char*) std::malloc(len);
+		result = (unsigned char*) malloc(len);
 		memcpy(result, wkbstring.c_str(), len);
 		*size = len;
 		return result;
@@ -2213,7 +2214,7 @@
 {
 	try
 	{
-		return writer->setOutputDimension(newDimension);
+		writer->setOutputDimension(newDimension);
 	}
 
 	catch (...)
@@ -2242,7 +2243,7 @@
 {
 	try
 	{
-		return writer->setByteOrder(newByteOrder);
+		writer->setByteOrder(newByteOrder);
 	}
 
 	catch (...)
Index: source/algorithm/ConvexHull.cpp
===================================================================
--- source/algorithm/ConvexHull.cpp	(revision 2101)
+++ source/algorithm/ConvexHull.cpp	(working copy)
@@ -18,6 +18,7 @@
  *
  **********************************************************************/
 
+#include <geos/platform.h>
 #include <geos/algorithm/ConvexHull.h>
 #include <geos/algorithm/CGAlgorithms.h>
 #include <geos/geom/GeometryFactory.h>
@@ -164,7 +165,7 @@
 	// Remove consecutive equal Coordinates
 	// unique() returns an iterator to the end of the resulting
 	// sequence, we erase from there to the end.
-	dest.erase( unique(dest.begin(),dest.end()), dest.end() );
+	dest.erase( std::unique(dest.begin(),dest.end()), dest.end() );
 
 	// points must all lie in a line	
 	if ( dest.size() < 3 ) return false;
@@ -206,9 +207,16 @@
 			reducedSet.insert(pts[i]);
 		}
 	}
-
+#if WIN32 && _MSC_VER == 1200
+	inputPts.clear();
+	std::set<const Coordinate *, CoordinateLessThen>::iterator it;
+	for (it = reducedSet.begin(); it != reducedSet.end(); it++)
+	{
+		inputPts.push_back(*it);
+	}
+#else
 	inputPts.assign(reducedSet.begin(), reducedSet.end());
- 
+#endif
 }
 
 Geometry*
@@ -269,7 +277,7 @@
 	}
 
 	// sort the points radially around the focal point.
-	sort(pts.begin(), pts.end(), RadiallyLessThen(pts[0]));
+	std::sort(pts.begin(), pts.end(), RadiallyLessThen(pts[0]));
 }
 
 /*private*/
Index: source/algorithm/HCoordinate.cpp
===================================================================
--- source/algorithm/HCoordinate.cpp	(revision 2101)
+++ source/algorithm/HCoordinate.cpp	(working copy)
@@ -21,7 +21,6 @@
 #include <geos/algorithm/HCoordinate.h>
 #include <geos/algorithm/NotRepresentableException.h>
 #include <geos/geom/Coordinate.h>
-#include <geos/platform.h>
 
 #include <memory>
 #include <cmath>
@@ -185,7 +184,7 @@
 {
 	long double a = x/w;
 
-    if (std::fabs(a) > std::numeric_limits<double>::max())
+    if (fabs(a) > std::numeric_limits<double>::max())
 	{
 		throw  NotRepresentableException();
 	}
@@ -198,7 +197,7 @@
 {
 	long double a = y/w;
 
-    if (std::fabs(a) > std::numeric_limits<double>::max())
+    if (fabs(a) > std::numeric_limits<double>::max())
 	{
 		throw  NotRepresentableException();
 	}
Index: source/algorithm/InteriorPointArea.cpp
===================================================================
--- source/algorithm/InteriorPointArea.cpp	(revision 2101)
+++ source/algorithm/InteriorPointArea.cpp	(working copy)
@@ -126,8 +126,8 @@
 	//Start at 1
 	for(std::size_t i=1, n=gc->getNumGeometries(); i<n; i++)
 	{
-		const Envelope *env1(gc->getGeometryN(i)->getEnvelopeInternal());
-		const Envelope *env2(widestGeometry->getEnvelopeInternal());
+		const Envelope *env1 = gc->getGeometryN(i)->getEnvelopeInternal();
+		const Envelope *env2 = widestGeometry->getEnvelopeInternal();
 		if (env1->getWidth()>env2->getWidth()) {
 				widestGeometry=gc->getGeometryN(i);
 		}
Index: source/algorithm/PointLocator.cpp
===================================================================
--- source/algorithm/PointLocator.cpp	(revision 2101)
+++ source/algorithm/PointLocator.cpp	(working copy)
@@ -18,6 +18,7 @@
  *
  **********************************************************************/
 
+#include <geos/platform.h>
 #include <geos/algorithm/PointLocator.h>
 #include <geos/algorithm/CGAlgorithms.h>
 #include <geos/geom/Geometry.h>
Index: source/geom/Geometry.cpp
===================================================================
--- source/geom/Geometry.cpp	(revision 2101)
+++ source/geom/Geometry.cpp	(working copy)
@@ -121,7 +121,8 @@
 {
 	if ( geom.envelope.get() )
 	{
-		envelope.reset(new Envelope(*(geom.envelope)));
+		std::auto_ptr<Envelope> temp(new Envelope(*(geom.envelope)));
+		envelope = temp;
 	}
 	//factory=geom.factory; 
 	//envelope(new Envelope(*(geom.envelope.get())));
@@ -279,7 +280,8 @@
 Geometry::geometryChangedAction()
 {
 	//delete envelope;
-	envelope.reset(NULL);
+	std::auto_ptr<Envelope> temp(NULL);
+	envelope = temp;
 }
 
 bool
Index: source/geom/LineString.cpp
===================================================================
--- source/geom/LineString.cpp	(revision 2101)
+++ source/geom/LineString.cpp	(working copy)
@@ -67,7 +67,8 @@
 {
 	if (points.get()==NULL)
 	{
-		points.reset(getFactory()->getCoordinateSequenceFactory()->create(NULL));
+		std::auto_ptr<CoordinateSequence> temp(getFactory()->getCoordinateSequenceFactory()->create(NULL));
+		points = temp;
 		return;
 	}
 
Index: source/geom/MultiLineString.cpp
===================================================================
--- source/geom/MultiLineString.cpp	(revision 2101)
+++ source/geom/MultiLineString.cpp	(working copy)
@@ -14,6 +14,7 @@
  *
  **********************************************************************/
 
+#include <geos/platform.h>
 #include <geos/operation/IsSimpleOp.h>
 #include <geos/algorithm/CGAlgorithms.h>
 #include <geos/geomgraph/GeometryGraph.h>
Index: source/geom/Point.cpp
===================================================================
--- source/geom/Point.cpp	(revision 2101)
+++ source/geom/Point.cpp	(working copy)
@@ -44,7 +44,8 @@
 	coordinates(newCoords)
 {
 	if (coordinates.get()==NULL) {
-		coordinates.reset(factory->getCoordinateSequenceFactory()->create(NULL));
+		std::auto_ptr<CoordinateSequence> temp(factory->getCoordinateSequenceFactory()->create(NULL));
+		coordinates = temp;
 		return;
 	}        
 	if (coordinates->getSize() != 1)
Index: source/geom/Polygon.cpp
===================================================================
--- source/geom/Polygon.cpp	(revision 2101)
+++ source/geom/Polygon.cpp	(working copy)
@@ -436,7 +436,8 @@
 
 	// check vertices have correct values
 	const Envelope &env = *getEnvelopeInternal();
-	for (int i=0; i<5; i++) {
+	int i;
+	for (i=0; i<5; i++) {
 		double x = seq.getX(i);
 		if (! (x == env.getMinX() || x == env.getMaxX())) return false;
 		double y = seq.getY(i);
@@ -446,7 +447,7 @@
 	// check vertices are in right order
 	double prevX = seq.getX(0);
 	double prevY = seq.getY(0);
-	for (int i = 1; i <= 4; i++) {
+	for (i = 1; i <= 4; i++) {
 		double x = seq.getX(i);
 		double y = seq.getY(i);
 		bool xChanged = (x != prevX);
Index: source/geomgraph/DirectedEdgeStar.cpp
===================================================================
--- source/geomgraph/DirectedEdgeStar.cpp	(revision 2101)
+++ source/geomgraph/DirectedEdgeStar.cpp	(working copy)
@@ -18,6 +18,7 @@
  *
  **********************************************************************/
 
+#include <geos/platform.h>
 #include <geos/geomgraph/DirectedEdgeStar.h>
 #include <geos/geomgraph/EdgeEndStar.h>
 #include <geos/geomgraph/EdgeEnd.h>
@@ -361,7 +362,8 @@
 	int startLoc=Location::UNDEF;
 
 	EdgeEndStar::iterator endIt=end();
-	for (EdgeEndStar::iterator it=begin(); it!=endIt; ++it)
+	EdgeEndStar::iterator it;
+	for (it=begin(); it!=endIt; ++it)
 	{
 		assert(*it);
         	assert(dynamic_cast<DirectedEdge*>(*it));
@@ -391,7 +393,7 @@
 	 * If L edges are found, mark them as covered if they are in the interior
 	 */
 	int currLoc=startLoc;
-	for (EdgeEndStar::iterator it=begin(); it!=endIt; ++it)
+	for (it=begin(); it!=endIt; ++it)
 	{
 		assert(*it);
         	assert(dynamic_cast<DirectedEdge*>(*it));
Index: source/geomgraph/EdgeEndStar.cpp
===================================================================
--- source/geomgraph/EdgeEndStar.cpp	(revision 2101)
+++ source/geomgraph/EdgeEndStar.cpp	(working copy)
@@ -129,7 +129,8 @@
 	bool hasDimensionalCollapseEdge[2]={false,false};
 
 	EdgeEndStar::iterator endIt=end();
-	for (EdgeEndStar::iterator it=begin(); it!=endIt; ++it)
+	EdgeEndStar::iterator it;
+	for (it=begin(); it!=endIt; ++it)
 	{
 		EdgeEnd *e=*it;
 		assert(e);
@@ -142,7 +143,7 @@
 		}
 	}
 
-	for (EdgeEndStar::iterator it=begin(); it!=end(); ++it)
+	for (it=begin(); it!=end(); ++it)
 	{
 		EdgeEnd *e=*it;
 		assert(e);
@@ -211,10 +212,10 @@
 	if (edgeMap.size()==0) return true;
 
 	// initialize startLoc to location of last L side (if any)
-	EdgeEndStar::reverse_iterator it=rbegin();
+	EdgeEndStar::reverse_iterator rit=rbegin();
 
-	assert(*it);
-	Label *startLabel=(*it)->getLabel();
+	assert(*rit);
+	Label *startLabel=(*rit)->getLabel();
 	int startLoc=startLabel->getLocation(geomIndex, Position::LEFT);
 
 	// Found unlabelled area edge
@@ -265,7 +266,7 @@
 	EdgeEndStar::iterator it;
 
 	// initialize loc to location of last L side (if any)
-	for (EdgeEndStar::iterator it=beginIt; it!=endIt; ++it)
+	for (it=beginIt; it!=endIt; ++it)
 	{
 		EdgeEnd *e=*it;
 		assert(e);
Index: source/geomgraph/EdgeNodingValidator.cpp
===================================================================
--- source/geomgraph/EdgeNodingValidator.cpp	(revision 2101)
+++ source/geomgraph/EdgeNodingValidator.cpp	(working copy)
@@ -46,11 +46,11 @@
 EdgeNodingValidator::~EdgeNodingValidator()
 {
 	for (SegmentString::NonConstVect::iterator
-			i=segStr.begin(), e=segStr.end();
-			i != e;
-			++i)
+			it=segStr.begin(), e=segStr.end();
+			it != e;
+			++it)
 	{
-		delete *i;
+		delete *it;
 	}
 
 	for(size_t i=0, n=newCoordSeq.size(); i<n; ++i)
Index: source/geomgraph/GeometryGraph.cpp
===================================================================
--- source/geomgraph/GeometryGraph.cpp	(revision 2101)
+++ source/geomgraph/GeometryGraph.cpp	(working copy)
@@ -109,7 +109,8 @@
 {
 	if ( ! boundaryNodes.get() )
 	{
-		boundaryNodes.reset(new vector<Node*>());
+		std::auto_ptr< std::vector<Node*> > temp(new vector<Node*>());
+		boundaryNodes = temp;
 		getBoundaryNodes(*(boundaryNodes.get()));
 	}
 	return boundaryNodes.get();
@@ -124,7 +125,8 @@
 	{
 		// Collection will be destroied by GeometryGraph dtor
 		vector<Node*>* coll = getBoundaryNodes();
-		boundaryPoints.reset(new CoordinateArraySequence(coll->size()));
+		std::auto_ptr<CoordinateSequence> temp(new CoordinateArraySequence(coll->size()));
+		boundaryPoints = temp;
 		size_t i=0;
 		for (vector<Node*>::iterator it=coll->begin(), endIt=coll->end();
 			it!=endIt; ++it)
Index: source/geomgraph/index/MonotoneChainEdge.cpp
===================================================================
--- source/geomgraph/index/MonotoneChainEdge.cpp	(revision 2101)
+++ source/geomgraph/index/MonotoneChainEdge.cpp	(working copy)
@@ -17,6 +17,7 @@
 #include <cassert>
 #include <vector>
 
+#include <geos/platform.h>
 #include <geos/geomgraph/Edge.h>
 #include <geos/geomgraph/index/MonotoneChainEdge.h>
 #include <geos/geomgraph/index/MonotoneChainIndexer.h>
Index: source/geomgraph/PlanarGraph.cpp
===================================================================
--- source/geomgraph/PlanarGraph.cpp	(revision 2101)
+++ source/geomgraph/PlanarGraph.cpp	(working copy)
@@ -94,14 +94,15 @@
 PlanarGraph::~PlanarGraph()
 {
 	delete nodes;
+	size_t i, n;
 #if 1 // FIXME: PlanarGraph should *not* own edges!
-	for(size_t i=0, n=edges->size(); i<n; i++) {
+	for(i=0, n=edges->size(); i<n; i++) {
 		delete (*edges)[i];
 	}
 #endif
 	delete edges;
 
-	for(size_t i=0, n=edgeEndList->size(); i<n; i++) {
+	for(i=0, n=edgeEndList->size(); i<n; i++) {
 		delete (*edgeEndList)[i];
 	}
 	delete edgeEndList;
Index: source/headers/geos/geom/BinaryOp.h
===================================================================
--- source/headers/geos/geom/BinaryOp.h	(revision 2101)
+++ source/headers/geos/geom/BinaryOp.h	(working copy)
@@ -205,7 +205,8 @@
 #if GEOS_DEBUG_BINARYOP
 		std::cerr << "Trying with original input." << std::endl;
 #endif
-		ret.reset(_Op(g0, g1));
+		std::auto_ptr<Geometry> temp(_Op(g0, g1));
+		ret = temp;
 		return ret;
 	}
 	catch (const util::TopologyException& ex)
@@ -233,8 +234,10 @@
 		cbr.add(g0);
 		cbr.add(g1);
 
-		rG0.reset( cbr.removeCommonBits(g0->clone()) );
-		rG1.reset( cbr.removeCommonBits(g1->clone()) );
+		std::auto_ptr<Geometry> temp0(cbr.removeCommonBits(g0->clone()));
+		rG0 = temp0;
+		std::auto_ptr<Geometry> temp1(cbr.removeCommonBits(g0->clone()));
+		rG1 = temp1;
 
 #if GEOS_DEBUG_BINARYOP
 		if ( ! rG0->isValid() )
@@ -248,7 +251,8 @@
 		}
 #endif
 
-		ret.reset( _Op(rG0.get(), rG1.get()) );
+		std::auto_ptr<Geometry> temp(_Op(rG0.get(), rG1.get()));
+		ret = temp;
 
 		cbr.addCommonBits( ret.get() );
 
Index: source/headers/geos/geom/CoordinateList.h
===================================================================
--- source/headers/geos/geom/CoordinateList.h	(revision 2101)
+++ source/headers/geos/geom/CoordinateList.h	(working copy)
@@ -101,7 +101,9 @@
 	std::auto_ptr<Coordinate::Vect> toCoordinateArray() const
 	{
 		std::auto_ptr<Coordinate::Vect> ret(new Coordinate::Vect);
-		ret->assign(coords.begin(), coords.end());
+		std::list<Coordinate>::const_iterator it;
+		for (it = coords.begin(); it != coords.end(); it++)
+			ret->push_back(*it);
 		return ret;
 	}
 
Index: source/headers/geos/geom/PrecisionModel.inl
===================================================================
--- source/headers/geos/geom/PrecisionModel.inl	(revision 2101)
+++ source/headers/geos/geom/PrecisionModel.inl	(working copy)
@@ -38,7 +38,7 @@
 PrecisionModel::makePrecise(Coordinate* coord) const
 {
 	assert(coord);
-	return makePrecise(*coord);
+	makePrecise(*coord);
 }
 
 /*public*/
Index: source/headers/geos/index/quadtree/DoubleBits.h
===================================================================
--- source/headers/geos/index/quadtree/DoubleBits.h	(revision 2101)
+++ source/headers/geos/index/quadtree/DoubleBits.h	(working copy)
@@ -45,7 +45,7 @@
 
 public:
 
-	static const int EXPONENT_BIAS=1023;
+	static const int EXPONENT_BIAS;
 
 	static double powerOf2(int exp);
 
Index: source/headers/geos/index/quadtree/IntervalSize.h
===================================================================
--- source/headers/geos/index/quadtree/IntervalSize.h	(revision 2101)
+++ source/headers/geos/index/quadtree/IntervalSize.h	(working copy)
@@ -42,7 +42,7 @@
 	 * to be correct,
 	 * at least for comparison purposes.
 	 */
-	static const int MIN_BINARY_EXPONENT=-50;
+	static const int MIN_BINARY_EXPONENT;
 	static bool isZeroWidth(double min, double max);
 };
 
Index: source/headers/geos/index/strtree/AbstractSTRtree.h
===================================================================
--- source/headers/geos/index/strtree/AbstractSTRtree.h	(revision 2101)
+++ source/headers/geos/index/strtree/AbstractSTRtree.h	(working copy)
@@ -79,7 +79,7 @@
 	bool remove(const void* searchBounds, AbstractNode& node, void* item);
 	bool removeItem(AbstractNode& node, void* item);
 
-protected:
+public:
 
 	/** \brief
 	 * A test for intersection between two bounds, necessary because
@@ -102,6 +102,7 @@
 			virtual ~IntersectsOp() {}
 	};
 
+protected:
 	AbstractNode *root;
 
 	std::vector <AbstractNode *> *nodes;
Index: source/headers/geos/index/strtree/SIRtree.h
===================================================================
--- source/headers/geos/index/strtree/SIRtree.h	(revision 2101)
+++ source/headers/geos/index/strtree/SIRtree.h	(working copy)
@@ -16,6 +16,7 @@
 #ifndef GEOS_INDEX_STRTREE_SIRTREE_H
 #define GEOS_INDEX_STRTREE_SIRTREE_H
 
+#include <geos/platform.h>
 #include <geos/index/strtree/AbstractSTRtree.h> // for inheritance
 #include <geos/index/strtree/Interval.h> // for inline
 
Index: source/headers/geos/index/strtree/STRtree.h
===================================================================
--- source/headers/geos/index/strtree/STRtree.h	(revision 2101)
+++ source/headers/geos/index/strtree/STRtree.h	(working copy)
@@ -130,7 +130,7 @@
 	}
 
 	void query(const geom::Envelope *searchEnv, ItemVisitor& visitor) {
-		return AbstractSTRtree::query(searchEnv, visitor);
+		AbstractSTRtree::query(searchEnv, visitor);
 	}
 
 	bool remove(const geom::Envelope *itemEnv, void* item) {
Index: source/headers/geos/noding/IteratedNoder.h
===================================================================
--- source/headers/geos/noding/IteratedNoder.h	(revision 2101)
+++ source/headers/geos/noding/IteratedNoder.h	(working copy)
@@ -50,7 +50,7 @@
 class IteratedNoder : public Noder { // implements Noder
 
 private:
-	static const int MAX_ITER = 5;
+	static const int MAX_ITER;
 
 
 	const geom::PrecisionModel *pm;
Index: source/headers/geos/noding/MCIndexNoder.h
===================================================================
--- source/headers/geos/noding/MCIndexNoder.h	(revision 2101)
+++ source/headers/geos/noding/MCIndexNoder.h	(working copy)
@@ -60,8 +60,11 @@
 	int nOverlaps;
 
 	void intersectChains();
-
+#if WIN32 && _MSC_VER == 1200
+	bool add(SegmentString* segStr);
+#else
 	void add(SegmentString* segStr);
+#endif
 
 public:
 
Index: source/headers/geos/noding/snapround/MCIndexSnapRounder.h
===================================================================
--- source/headers/geos/noding/snapround/MCIndexSnapRounder.h	(revision 2101)
+++ source/headers/geos/noding/snapround/MCIndexSnapRounder.h	(working copy)
@@ -109,8 +109,11 @@
 	 * Performs a brute-force comparison of every segment in each {@link SegmentString}.
 	 * This has n^2 performance.
 	 */
+#if WIN32 && _MSC_VER == 1200
+	bool computeEdgeVertexSnaps(SegmentString* e);
+#else
 	void computeEdgeVertexSnaps(SegmentString* e);
-	
+#endif
 	void checkCorrectness(std::vector<SegmentString*>& inputSegmentStrings);
 
 public:
Index: source/headers/geos/operation/buffer/BufferOp.h
===================================================================
--- source/headers/geos/operation/buffer/BufferOp.h	(revision 2101)
+++ source/headers/geos/operation/buffer/BufferOp.h	(working copy)
@@ -74,7 +74,7 @@
 	 * 
 	 *  This value should be less than the decimal precision of double-precision values (16).
 	 */
-	static const int MAX_PRECISION_DIGITS = 12;
+	static const int MAX_PRECISION_DIGITS;
 
 	/**
 	 * Compute a reasonable scale factor to limit the precision of
Index: source/headers/geos/operation/buffer/OffsetCurveBuilder.h
===================================================================
--- source/headers/geos/operation/buffer/OffsetCurveBuilder.h	(revision 2101)
+++ source/headers/geos/operation/buffer/OffsetCurveBuilder.h	(working copy)
@@ -68,7 +68,7 @@
 	 * A value of 8 gives less than 2% max error in the buffer distance.
 	 * For a max error of < 1%, use QS = 12
 	 */
-	static const int DEFAULT_QUADRANT_SEGMENTS=8;
+	static const int DEFAULT_QUADRANT_SEGMENTS;
 
 	OffsetCurveBuilder(const geom::PrecisionModel *newPrecisionModel,
 			int quadrantSegments=DEFAULT_QUADRANT_SEGMENTS);
Index: source/headers/geos/operation/distance/GeometryLocation.h
===================================================================
--- source/headers/geos/operation/distance/GeometryLocation.h	(revision 2101)
+++ source/headers/geos/operation/distance/GeometryLocation.h	(working copy)
@@ -51,7 +51,7 @@
 	 * Special value of segment-index for locations inside area geometries. These
 	 * locations do not have an associated segment index.
 	 */
-	static const int INSIDE_AREA = -1;
+	static const int INSIDE_AREA;
 
 	/**
 	 * Constructs a GeometryLocation specifying a point on a geometry, as well as the 
Index: source/headers/geos/operation/overlay/OffsetPointGenerator.h
===================================================================
--- source/headers/geos/operation/overlay/OffsetPointGenerator.h	(revision 2101)
+++ source/headers/geos/operation/overlay/OffsetPointGenerator.h	(working copy)
@@ -61,9 +61,11 @@
 	double offsetDistance;
 
 	std::auto_ptr< std::vector<geom::Coordinate> > offsetPts;
-
-	void extractPoints(const geom::LineString* line);
-
+#if WIN32 && _MSC_VER == 1200
+	bool extractPoints(const geom::LineString* line);
+#else
+	void extractPoints(const geom::LineString* line);
+#endif
 	void computeOffsets(const geom::Coordinate& p0,
 			const geom::Coordinate& p1);
 };
Index: source/headers/geos/operation/overlay/OverlayOp.h
===================================================================
--- source/headers/geos/operation/overlay/OverlayOp.h	(revision 2101)
+++ source/headers/geos/operation/overlay/OverlayOp.h	(working copy)
@@ -129,8 +129,11 @@
 	 * If so, the edge is not inserted, but its label is merged
 	 * with the existing edge.
 	 */
+#if WIN32 && _MSC_VER == 1200
+	bool insertUniqueEdge(geomgraph::Edge *e);
+#else
 	void insertUniqueEdge(geomgraph::Edge *e);
-
+#endif
 private:
 
 	algorithm::PointLocator ptLocator;
@@ -150,8 +153,11 @@
 	std::vector<geom::Point*> *resultPointList;
 
 	void computeOverlay(OpCode opCode); // throw(TopologyException *);
-
+#if WIN32 && _MSC_VER == 1200
+	bool insertUniqueEdges(std::vector<geomgraph::Edge*> *edges);
+#else
 	void insertUniqueEdges(std::vector<geomgraph::Edge*> *edges);
+#endif
 
 	/*
 	 * If either of the GeometryLocations for the existing label is
Index: source/headers/geos/platform.h.vc
===================================================================
--- source/headers/geos/platform.h.vc	(revision 2101)
+++ source/headers/geos/platform.h.vc	(working copy)
@@ -26,6 +26,23 @@
 #define WIN32
 #endif
 
+#if _MSC_VER == 1200
+#pragma warning(disable:4786)
+#define PREVENT_MACRO_SUBSTITUTION
+namespace std
+{
+	using ::size_t;
+	template <class _Tp>
+	inline const _Tp& min PREVENT_MACRO_SUBSTITUTION (const _Tp& __a, const _Tp& __b) {
+		return __b < __a ? __b : __a;
+	}
+	template <class _Tp>
+	inline const _Tp& max PREVENT_MACRO_SUBSTITUTION (const _Tp& __a, const _Tp& __b) {
+		return __a < __b ? __b : __a;
+	}
+}
+#endif
+
 #include <float.h>
 
 // We need M_PI, but on MSVC you need to define _USE_MATH_DEFINES before
Index: source/headers/geos/profiler.h
===================================================================
--- source/headers/geos/profiler.h	(revision 2101)
+++ source/headers/geos/profiler.h	(working copy)
@@ -16,6 +16,8 @@
 #ifndef GEOS_PROFILER_H
 #define GEOS_PROFILER_H
 
+#include <geos/platform.h>
+
 /* For MingW builds with __STRICT_ANSI__ (-ansi) */
 #if defined(__MINGW32__)
 /* Allow us to check for presence of gettimeofday in MingW */ 
Index: source/headers/geos/simplify/TaggedLinesSimplifier.h
===================================================================
--- source/headers/geos/simplify/TaggedLinesSimplifier.h	(revision 2101)
+++ source/headers/geos/simplify/TaggedLinesSimplifier.h	(working copy)
@@ -84,13 +84,14 @@
 		iterator_type end)
 	{
 		// add lines to the index
-		for (iterator_type it=begin; it != end; ++it) {
+		iterator_type it=begin;
+		for (it=begin; it != end; ++it) {
 			assert(*it);
 			inputIndex->add(*(*it));
 		}
 
 		// Simplify lines
-		for (iterator_type it=begin; it != end; ++it) {
+		for (it=begin; it != end; ++it) {
 			assert(*it);
 			simplify(*(*it));
 		}
Index: source/headers/geos/version.h.vc
===================================================================
--- source/headers/geos/version.h.vc	(revision 2101)
+++ source/headers/geos/version.h.vc	(working copy)
@@ -29,8 +29,8 @@
 
 #define GEOS_VERSION_MAJOR 3
 #define GEOS_VERSION_MINOR 0
-#define GEOS_VERSION_PATCH 0rc4
-#define GEOS_VERSION "3.0.0rc4"
+#define GEOS_VERSION_PATCH 0
+#define GEOS_VERSION "3.0.0"
 #define GEOS_JTS_PORT "1.7.1"
 
 #endif // GEOS_VERSION_H
Index: source/index/quadtree/DoubleBits.cpp
===================================================================
--- source/index/quadtree/DoubleBits.cpp	(revision 2101)
+++ source/index/quadtree/DoubleBits.cpp	(working copy)
@@ -39,6 +39,8 @@
 
 using namespace std;
 
+const int DoubleBits::EXPONENT_BIAS=1023;
+
 double
 DoubleBits::powerOf2(int exp)
 {
Index: source/index/quadtree/IntervalSize.cpp
===================================================================
--- source/index/quadtree/IntervalSize.cpp	(revision 2101)
+++ source/index/quadtree/IntervalSize.cpp	(working copy)
@@ -25,7 +25,7 @@
 namespace geos {
 namespace index { // geos.index
 namespace quadtree { // geos.index.quadtree
-
+const int IntervalSize::MIN_BINARY_EXPONENT=-50;
 bool IntervalSize::isZeroWidth(double mn,double mx){
 	double width=mx-mn;
 	if (width==0.0) return true;
Index: source/index/strtree/AbstractSTRtree.cpp
===================================================================
--- source/index/strtree/AbstractSTRtree.cpp	(revision 2101)
+++ source/index/strtree/AbstractSTRtree.cpp	(working copy)
@@ -35,12 +35,12 @@
 {
 	assert(itemBoundables);
 
-	for (BoundableList::iterator i=itemBoundables->begin(),
+	for (BoundableList::iterator it=itemBoundables->begin(),
 			e=itemBoundables->end();
-			i!=e;
-			++i)
+			it!=e;
+			++it)
 	{
-		delete *i; 
+		delete *it; 
 	}
 	delete itemBoundables;
 
Index: source/index/strtree/Interval.cpp
===================================================================
--- source/index/strtree/Interval.cpp	(revision 2101)
+++ source/index/strtree/Interval.cpp	(working copy)
@@ -16,6 +16,7 @@
 
 #include <geos/index/strtree/Interval.h>
 //#include <geos/util.h>
+#include <geos/platform.h>
 
 #include <algorithm>
 #include <typeinfo>
Index: source/io/WKBWriter.cpp
===================================================================
--- source/io/WKBWriter.cpp	(revision 2101)
+++ source/io/WKBWriter.cpp	(working copy)
@@ -68,30 +68,38 @@
 
 	switch (g.getGeometryTypeId()) {
 		case GEOS_POINT:
-			return writePoint((Point &)g);
+			writePoint((Point &)g);
+			break;
 		case GEOS_LINESTRING:
 		case GEOS_LINEARRING:
-			return writeLineString((LineString &)g);
+			writeLineString((LineString &)g);
+			break;
 		case GEOS_POLYGON:
-			return writePolygon((Polygon &)g);
+			writePolygon((Polygon &)g);
+			break;
 		case GEOS_MULTIPOINT:
-			return writeGeometryCollection(
+			writeGeometryCollection(
 				(GeometryCollection &)g,
 				WKBConstants::wkbMultiPoint);
+			break;
 		case GEOS_MULTILINESTRING:
-			return writeGeometryCollection(
+			writeGeometryCollection(
 				(GeometryCollection &)g,
 				WKBConstants::wkbMultiLineString);
+			break;
 		case GEOS_MULTIPOLYGON:
-			return writeGeometryCollection(
+			writeGeometryCollection(
 				(GeometryCollection &)g,
 				WKBConstants::wkbMultiPolygon);
+			break;
 		case GEOS_GEOMETRYCOLLECTION:
-			return writeGeometryCollection(
+			writeGeometryCollection(
 				(GeometryCollection &)g,
 				WKBConstants::wkbGeometryCollection);
+			break;
 		default:
 			assert(0); // Unknown Geometry type
+			break;
 	}
 }
 
Index: source/noding/FastNodingValidator.cpp
===================================================================
--- source/noding/FastNodingValidator.cpp	(revision 2101)
+++ source/noding/FastNodingValidator.cpp	(working copy)
@@ -34,8 +34,9 @@
 void
 FastNodingValidator::checkInteriorIntersections()
 {
-	isValidVar = true;
-	segInt.reset(new SingleInteriorIntersectionFinder(li));
+	isValidVar = true;
+	std::auto_ptr<SingleInteriorIntersectionFinder> temp(new SingleInteriorIntersectionFinder(li));
+	segInt = temp;
 	MCIndexNoder noder;
 	noder.setSegmentIntersector(segInt.get());
 	noder.computeNodes(&segStrings);
Index: source/noding/IteratedNoder.cpp
===================================================================
--- source/noding/IteratedNoder.cpp	(revision 2101)
+++ source/noding/IteratedNoder.cpp	(working copy)
@@ -38,6 +38,8 @@
 namespace geos {
 namespace noding { // geos.noding
 
+const int MAX_ITER = 5;
+
 /*
  * Node the input segment strings once
  * and create the split edges between the nodes
Index: source/noding/MCIndexNoder.cpp
===================================================================
--- source/noding/MCIndexNoder.cpp	(revision 2101)
+++ source/noding/MCIndexNoder.cpp	(working copy)
@@ -47,10 +47,12 @@
 {
 	nodedSegStrings = inputSegStrings;
 	assert(nodedSegStrings);
-
 	for_each(nodedSegStrings->begin(), nodedSegStrings->end(),
-			bind1st(mem_fun(&MCIndexNoder::add), this));
-
+#if WIN32 && _MSC_VER == 1200
+			bind1st(mem_fun1(&MCIndexNoder::add), this));
+#else
+			bind1st(mem_fun1(&MCIndexNoder::add), this));
+#endif
 	intersectChains();
 //cerr<<"MCIndexNoder: # chain overlaps = "<<nOverlaps<<endl;
 }
@@ -100,7 +102,11 @@
 }
 
 /*private*/
+#if WIN32 && _MSC_VER == 1200
+bool
+#else
 void
+#endif
 MCIndexNoder::add(SegmentString* segStr)
 {
 	vector<MonotoneChain*> segChains;
@@ -122,6 +128,9 @@
 		// MonotoneChain objects deletion delegated to destructor
 		monoChains.push_back(mc);
 	}
+#if WIN32 && _MSC_VER == 1200
+	return true;
+#endif
 }
 
 MCIndexNoder::~MCIndexNoder()
Index: source/noding/SegmentNodeList.cpp
===================================================================
--- source/noding/SegmentNodeList.cpp	(revision 2101)
+++ source/noding/SegmentNodeList.cpp	(working copy)
@@ -56,12 +56,13 @@
 		delete *it;
 	}
 
-	for(size_t i=0, n=splitEdges.size(); i<n; ++i)
+	size_t i, n;
+	for(i=0, n=splitEdges.size(); i<n; ++i)
 	{
 		delete splitEdges[i];
 	}
 
-	for(size_t i=0, n=splitCoordLists.size(); i<n; ++i)
+	for(i=0, n=splitCoordLists.size(); i<n; ++i)
 	{
 		delete splitCoordLists[i];
 	}
Index: source/noding/snapround/MCIndexSnapRounder.cpp
===================================================================
--- source/noding/snapround/MCIndexSnapRounder.cpp	(revision 2101)
+++ source/noding/snapround/MCIndexSnapRounder.cpp	(working copy)
@@ -70,7 +70,11 @@
 }
 
 /*private*/
+#if WIN32 && _MSC_VER == 1200
+bool
+#else
 void
+#endif
 MCIndexSnapRounder::computeEdgeVertexSnaps(SegmentString* e)
 {
 	CoordinateSequence& pts0 = *(e->getCoordinates());
@@ -83,13 +87,21 @@
 			e->addIntersection(pts0[i], i);
 		}
 	}
+#if WIN32 && _MSC_VER == 1200
+	return true;
+#endif
 }
 
 /*public*/
 void
 MCIndexSnapRounder::computeVertexSnaps(SegmentString::NonConstVect& edges)
 {
-	for_each(edges.begin(), edges.end(), bind1st(mem_fun(&MCIndexSnapRounder::computeEdgeVertexSnaps), this));
+	for_each(edges.begin(), edges.end(),
+#if WIN32 && _MSC_VER == 1200
+		bind1st(mem_fun1(&MCIndexSnapRounder::computeEdgeVertexSnaps), this));
+#else
+		bind1st(mem_fun(&MCIndexSnapRounder::computeEdgeVertexSnaps), this));
+#endif
 }
 
 /*private*/
@@ -111,7 +123,8 @@
 	nodedSegStrings = inputSegmentStrings;
 	MCIndexNoder noder;
 	pointSnapper.release(); // let it leak
-	pointSnapper.reset(new MCIndexPointSnapper(noder.getIndex()));
+	std::auto_ptr<MCIndexPointSnapper> temp(new MCIndexPointSnapper(noder.getIndex()));
+	pointSnapper = temp;
 	snapRound(noder, inputSegmentStrings);
 
 	// testing purposes only - remove in final version
Index: source/operation/buffer/BufferBuilder.cpp
===================================================================
--- source/operation/buffer/BufferBuilder.cpp	(revision 2101)
+++ source/operation/buffer/BufferBuilder.cpp	(working copy)
@@ -360,7 +360,7 @@
 	 * subgraphs for shells will have been built before the subgraphs for
 	 * any holes they contain
 	 */
-	sort(subgraphList.begin(), subgraphList.end(), BufferSubgraphGT);
+    std::sort(subgraphList.begin(), subgraphList.end(), BufferSubgraphGT);
 }
 
 /*private*/
Index: source/operation/buffer/BufferOp.cpp
===================================================================
--- source/operation/buffer/BufferOp.cpp	(revision 2101)
+++ source/operation/buffer/BufferOp.cpp	(working copy)
@@ -38,9 +38,8 @@
 #include <geos/noding/IntersectionAdder.h>
 #include <geos/noding/snapround/SimpleSnapRounder.h>
 
+#include <geos/platform.h>
 
-
-
 #ifndef GEOS_DEBUG
 #define GEOS_DEBUG 0
 #endif
@@ -54,6 +53,8 @@
 namespace operation { // geos.operation
 namespace buffer { // geos.operation.buffer
 
+const int BufferOp::MAX_PRECISION_DIGITS = 12;
+
 #if PROFILE
 static Profiler *profiler = Profiler::instance();
 #endif
@@ -65,7 +66,7 @@
 	int maxPrecisionDigits)
 {
 	const Envelope *env=g->getEnvelopeInternal();
-	double envSize=std::max(env->getHeight(), env->getWidth());
+	double envSize=max(env->getHeight(), env->getWidth());
 	double expandByDistance=distance > 0.0 ? distance : 0.0;
 	double bufEnvSize=envSize + 2 * expandByDistance;
 	// the smallest power of 10 greater than the buffer envelope
Index: source/operation/buffer/BufferSubgraph.cpp
===================================================================
--- source/operation/buffer/BufferSubgraph.cpp	(revision 2101)
+++ source/operation/buffer/BufferSubgraph.cpp	(working copy)
@@ -337,10 +337,11 @@
 	   << bs.nodes.size() << " nodes, "
 	   << bs.dirEdgeList.size() << " directed edges" << std::endl;
 
-	for (size_t i=0, n=bs.nodes.size(); i<n; i++)
+    size_t i, n;
+	for (i=0, n=bs.nodes.size(); i<n; i++)
 		os << "  Node " << i << ": " << *(bs.nodes[i]) << std::endl;
 
-	for (size_t i=0, n=bs.dirEdgeList.size(); i<n; i++)
+	for (i=0, n=bs.dirEdgeList.size(); i<n; i++)
 	{
 		os << "  DirEdge " << i << ": " << std::endl
 		   << bs.dirEdgeList[i]->printEdge() << std::endl;
Index: source/operation/buffer/OffsetCurveBuilder.cpp
===================================================================
--- source/operation/buffer/OffsetCurveBuilder.cpp	(revision 2101)
+++ source/operation/buffer/OffsetCurveBuilder.cpp	(working copy)
@@ -50,6 +50,7 @@
 const double OffsetCurveBuilder::MIN_CURVE_VERTEX_FACTOR = 1.0E-6;
 const double OffsetCurveBuilder::PI = 3.14159265358979;
 const double OffsetCurveBuilder::MAX_CLOSING_SEG_LEN = 3.0;
+const int OffsetCurveBuilder::DEFAULT_QUADRANT_SEGMENTS=8;
 
 /*public*/
 OffsetCurveBuilder::OffsetCurveBuilder(const PrecisionModel *newPrecisionModel,
@@ -158,7 +159,8 @@
 	int n=inputPts.size()-1;
 	// compute points for left side of line
 	initSideSegments(inputPts[0], inputPts[1], Position::LEFT);
-	for (int i=2;i<= n;i++) {
+    int i;
+	for (i=2;i<= n;i++) {
 		addNextSegment(inputPts[i], true);
 	}
 	addLastSegment();
@@ -166,7 +168,7 @@
 	addLineEndCap(inputPts[n-1], inputPts[n]);
 	// compute points for right side of line
 	initSideSegments(inputPts[n], inputPts[n-1], Position::LEFT);
-	for (int i=n-2; i>=0; i--) {
+	for (i=n-2; i>=0; i--) {
 		addNextSegment(inputPts[i], true);
 	}
 	addLastSegment();
Index: source/operation/buffer/OffsetCurveSetBuilder.cpp
===================================================================
--- source/operation/buffer/OffsetCurveSetBuilder.cpp	(revision 2101)
+++ source/operation/buffer/OffsetCurveSetBuilder.cpp	(working copy)
@@ -68,12 +68,13 @@
 OffsetCurveSetBuilder::~OffsetCurveSetBuilder()
 {
 	//delete cga;
-	for (size_t i=0, n=curveList.size(); i<n; ++i)
+    size_t i, n;
+	for (i=0, n=curveList.size(); i<n; ++i)
 	{
 		delete curveList[i]->getCoordinates();
 		delete curveList[i];
 	}
-	for (size_t i=0, n=newLabels.size(); i<n; ++i)
+	for (i=0, n=newLabels.size(); i<n; ++i)
 		delete newLabels[i];
 }
 
Index: source/operation/distance/GeometryLocation.cpp
===================================================================
--- source/operation/distance/GeometryLocation.cpp	(revision 2101)
+++ source/operation/distance/GeometryLocation.cpp	(working copy)
@@ -21,7 +21,7 @@
 namespace geos {
 namespace operation { // geos.operation
 namespace distance { // geos.operation.distance
-
+const int GeometryLocation::INSIDE_AREA = -1;
 /**
 * Constructs a GeometryLocation specifying a point on a geometry, as well as the 
 * segment that the point is on (or INSIDE_AREA if the point is not on a segment).
Index: source/operation/linemerge/LineSequencer.cpp
===================================================================
--- source/operation/linemerge/LineSequencer.cpp	(revision 2101)
+++ source/operation/linemerge/LineSequencer.cpp	(working copy)
@@ -163,7 +163,7 @@
 	if (isRun) return;
 	isRun = true;
 
-	Sequences* sequences(findSequences());
+	Sequences* sequences = findSequences();
 	if (sequences == NULL) return;
 
 	sequencedGeometry = auto_ptr<Geometry>(buildSequencedGeometry(*sequences));
Index: source/operation/overlay/OffsetPointGenerator.cpp
===================================================================
--- source/operation/overlay/OffsetPointGenerator.cpp	(revision 2101)
+++ source/operation/overlay/OffsetPointGenerator.cpp	(working copy)
@@ -58,19 +58,27 @@
 std::auto_ptr< std::vector<geom::Coordinate> >
 OffsetPointGenerator::getPoints()
 {
-	assert (offsetPts.get() == NULL);
-	offsetPts.reset(new vector<Coordinate>());
+	assert (offsetPts.get() == NULL);
+	std::auto_ptr< std::vector<geom::Coordinate> > temp(new vector<Coordinate>());
+	offsetPts = temp;
 
 	vector<const LineString*> lines;
 	geos::geom::util::LinearComponentExtracter::getLines(g, lines);
-	for_each(lines.begin(), lines.end(),
+	for_each(lines.begin(), lines.end(),
+#if WIN32 && _MSC_VER == 1200
+		bind1st(mem_fun1(&OffsetPointGenerator::extractPoints), this));
+#else
 		bind1st(mem_fun(&OffsetPointGenerator::extractPoints), this));
-
+#endif
 	return offsetPts;
 }
 
-/*private*/
-void
+/*private*/
+#if WIN32 && _MSC_VER == 1200
+bool
+#else
+void
+#endif
 OffsetPointGenerator::extractPoints(const LineString* line)
 {
 	const CoordinateSequence& pts = *(line->getCoordinatesRO());
@@ -79,7 +87,10 @@
 	for (size_t i=0, n=pts.size()-1; i<n; ++i)
 	{
 		computeOffsets(pts[i], pts[i + 1]);
-	}
+	}
+#if WIN32 && _MSC_VER == 1200
+	return true;
+#endif
 }
 
 /*private*/
Index: source/operation/overlay/OverlayOp.cpp
===================================================================
--- source/operation/overlay/OverlayOp.cpp	(revision 2101)
+++ source/operation/overlay/OverlayOp.cpp	(working copy)
@@ -188,11 +188,19 @@
 }
 
 /*private*/
+#if WIN32 && _MSC_VER == 1200
+bool
+#else
 void
+#endif
 OverlayOp::insertUniqueEdges(vector<Edge*> *edges)
 {
 	for_each(edges->begin(), edges->end(),
+#if WIN32 && _MSC_VER == 1200
+			bind1st(mem_fun1(&OverlayOp::insertUniqueEdge), this));
+#else
 			bind1st(mem_fun(&OverlayOp::insertUniqueEdge), this));
+#endif
 
 #if GEOS_DEBUG
 	cerr<<"OverlayOp::insertUniqueEdges("<<edges->size()<<"): "<<endl;
@@ -203,6 +211,9 @@
 	}
 #endif // GEOS_DEBUG
 
+#if WIN32 && _MSC_VER == 1200
+	return true;
+#endif
 }
 
 /*private*/
@@ -623,17 +634,17 @@
 	geomList->reserve(nPoints+nLines+nPolys);
 
 	// element geometries of the result are always in the order P,L,A
-	geomList->insert(geomList->end(),
-			nResultPointList->begin(),
-			nResultPointList->end());
+	vector<Point*>::iterator itPoint;
+	for (itPoint = nResultPointList->begin(); itPoint != nResultPointList->end(); itPoint++)
+		geomList->push_back(*itPoint);
 
-	geomList->insert(geomList->end(),
-			nResultLineList->begin(),
-			nResultLineList->end());
+	vector<LineString*>::iterator itLineString;
+	for (itLineString = nResultLineList->begin(); itLineString != nResultLineList->end(); itLineString++)
+		geomList->push_back(*itLineString);
 
-	geomList->insert(geomList->end(),
-			nResultPolyList->begin(),
-			nResultPolyList->end());
+	vector<Polygon*>::iterator itPolygon;
+	for (itPolygon = nResultPolyList->begin(); itPolygon != nResultPolyList->end(); itPolygon++)
+		geomList->push_back(*itPolygon);
 			
 	// build the most specific geometry possible
 	Geometry *g=geomFact->buildGeometry(geomList);
@@ -760,7 +771,11 @@
 }
 
 /*protected*/
+#if WIN32 && _MSC_VER == 1200
+bool
+#else
 void
+#endif
 OverlayOp::insertUniqueEdge(Edge *e)
 {
 	//Debug.println(e);
@@ -816,6 +831,9 @@
 		//e.getDepth().add(e.getLabel());
 		edgeList.add(e);
 	}
+#if WIN32 && _MSC_VER == 1200
+	return true;
+#endif
 }
 
 /*private*/
Index: source/operation/overlay/PolygonBuilder.cpp
===================================================================
--- source/operation/overlay/PolygonBuilder.cpp	(revision 2101)
+++ source/operation/overlay/PolygonBuilder.cpp	(working copy)
@@ -222,10 +222,9 @@
 			}
 			else
 			{
-				freeHoleList->insert(
-						freeHoleList->end(),
-						minEdgeRings->begin(),
-						minEdgeRings->end() );
+				vector<MinimalEdgeRing*>::iterator it;
+				for (it = minEdgeRings->begin(); it != minEdgeRings->end(); it++)
+					freeHoleList->push_back(*it);
 			}
 			delete er;
 			delete minEdgeRings;
Index: source/operation/valid/ConnectedInteriorTester.cpp
===================================================================
--- source/operation/valid/ConnectedInteriorTester.cpp	(revision 2101)
+++ source/operation/valid/ConnectedInteriorTester.cpp	(working copy)
@@ -149,7 +149,8 @@
 	cerr << "releasing " << edgeRings->size() << " edgeRings." << endl;
 #endif
 	// Release memory allocated by buildEdgeRings
-	for(size_t i=0, n=edgeRings->size(); i<n; ++i)
+	size_t i, n;
+	for(i=0, n=edgeRings->size(); i<n; ++i)
 	{
 		EdgeRing* er = (*edgeRings)[i];
 #if GEOS_DEBUG
@@ -167,7 +168,7 @@
 	// There should be no more references to this object
 	// how to check this ? boost::shared_ptr<> comes to mind.
 	//
-	for (size_t i=0, n=maximalEdgeRings.size(); i<n; i++)
+	for (i=0, n=maximalEdgeRings.size(); i<n; i++)
 	{
 		delete maximalEdgeRings[i];
 	}
@@ -225,7 +226,10 @@
 		}
 	}
 	std::vector<EdgeRing*> *edgeRings=new std::vector<EdgeRing*>();
-	edgeRings->assign(minEdgeRings.begin(), minEdgeRings.end());
+	edgeRings->clear();
+	std::vector<MinimalEdgeRing*>::iterator it;
+	for (it = minEdgeRings.begin(); it != minEdgeRings.end(); it++)
+		edgeRings->push_back(*it);
 	return edgeRings;
 }
 
Index: source/operation/valid/IsValidOp.cpp
===================================================================
--- source/operation/valid/IsValidOp.cpp	(revision 2101)
+++ source/operation/valid/IsValidOp.cpp	(working copy)
@@ -211,7 +211,8 @@
 	unsigned int ngeoms = g->getNumGeometries();
 	vector<const Polygon *>polys(ngeoms);
 
-	for (unsigned int i=0; i<ngeoms; ++i)
+	unsigned int i;
+	for (i=0; i<ngeoms; ++i)
 	{
 		const Polygon *p = (const Polygon *)g->getGeometryN(i);
 
@@ -238,14 +239,14 @@
 		if (validErr!=NULL) return;
 	}
 
-	for(unsigned int i=0; i<ngeoms; ++i)
+	for(i=0; i<ngeoms; ++i)
 	{
 		const Polygon *p=polys[i]; 
 		checkHolesInShell(p, &graph);
 		if (validErr!=NULL) return;
 	}
 
-	for(unsigned int i=0; i<ngeoms; ++i)
+	for(i=0; i<ngeoms; ++i)
 	{
 		const Polygon *p=polys[i];
 		checkHolesNotNested(p, &graph);
Index: source/precision/CommonBitsOp.cpp
===================================================================
--- source/precision/CommonBitsOp.cpp	(revision 2101)
+++ source/precision/CommonBitsOp.cpp	(working copy)
@@ -132,7 +132,8 @@
 Geometry*
 CommonBitsOp::removeCommonBits(const Geometry* geom0)
 {
-	cbr.reset(new CommonBitsRemover());
+	std::auto_ptr<CommonBitsRemover> temp(new CommonBitsRemover);
+	cbr = temp;
 	cbr->add(geom0);
 
 #if GEOS_DEBUG
@@ -153,7 +154,8 @@
 		std::auto_ptr<geom::Geometry>& rgeom1)
 	
 {
-	cbr.reset(new CommonBitsRemover());
+	std::auto_ptr<CommonBitsRemover> temp(new CommonBitsRemover());
+	cbr = temp;
 
 	cbr->add(geom0);
 	cbr->add(geom1);
@@ -163,8 +165,10 @@
 	cerr << "CommonBitsRemover bits: " << commonCoord.x << ", " << commonCoord.y << endl;
 #endif
 
-	rgeom0.reset(cbr->removeCommonBits(geom0->clone()));
-	rgeom1.reset(cbr->removeCommonBits(geom1->clone()));
+	std::auto_ptr<geom::Geometry> temp0(cbr->removeCommonBits(geom0->clone()));
+	rgeom0 = temp0;
+	std::auto_ptr<geom::Geometry> temp1(cbr->removeCommonBits(geom1->clone()));
+	rgeom1 = temp1;
 
 }
 
Index: source/simplify/LineSegmentIndex.cpp
===================================================================
--- source/simplify/LineSegmentIndex.cpp	(revision 2101)
+++ source/simplify/LineSegmentIndex.cpp	(working copy)
@@ -83,7 +83,8 @@
 	{
 		if ( this == &o ) return *this;
 		querySeg = o.querySeg;
-		items.reset(new vector<LineSegment*>(*(o.items.get())));
+		auto_ptr< vector<LineSegment*> > temp(new vector<LineSegment*>(*(o.items.get())));
+		items = temp;
 	}
 
 	void visitItem(void* item)
Index: source/simplify/TaggedLineString.cpp
===================================================================
--- source/simplify/TaggedLineString.cpp	(revision 2101)
+++ source/simplify/TaggedLineString.cpp	(working copy)
@@ -59,11 +59,11 @@
 	cerr << "TaggedLineString[" << this << "] destructor"
 	     << endl;
 #endif
-
-	for (size_t i=0, n=segs.size(); i<n; i++)
+	size_t i, n;
+	for (i=0, n=segs.size(); i<n; i++)
 		delete segs[i];
 
-	for (size_t i=0, n=resultSegs.size(); i<n; i++)
+	for (i=0, n=resultSegs.size(); i<n; i++)
 		delete resultSegs[i];
 }
 
